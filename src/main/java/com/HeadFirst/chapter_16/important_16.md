List - список. Применяется, когда имеет значение порядок следования

Set - множество. ИСпользуется, когда имеет значение уникальность, не допускает дубликаты

Map - (ассоциативный массив с парой ключ\значение)

ArrayList следует использовать, когда в приоритете доступ по индексу, так как эти операции выполняются за константное
время. Добавление в конец списка в среднем тоже выполняется за константное время. Кроме того в ArrayList нет
дополнительных расходов на хранение связки между элементами. Минусы в скорости вставки/удаления элементов находящихся не
в конце списка, так как при этой операции все элементы правее добавляемого/удаляемого сдвигаются.

TreeSet - хранит элемы отсортированными и предотвращает дублирование. Для использования TreeSet должно выполняться одно из условий:\
Элемы в списке обязаны иметь тип, который реализует интерфейс Comparable\
При создании TreeSet вы используете перегруженный конструктор, который принимает Comparator

HashMap - позволяет хранить элемы и получать к ним доступ с помощью пары ключ\значение

LinkedList - разработан, что бы обеспечить лучшую производительность в тех случаях, когда элемы вставляются и удаляются
посередине коллекции

HashSet - предотвращает дублирование и позволяет быстро найти заданный элем

LinkedHashMap - то же самое, что и HashMap, но умеет запоминать порядок вставки элемов. Можно настроить так, чьл юы
помнить, к какому элему в последний раз предоставлялся доступ

С помощью обобщений можно создавать коллекции, которые более строго следят за типами. Вследствие чего большинство
проблем отлавливается на этапе компиляции

Без обобщений компилятор с радостью позволил бы вам засунуть объект А в ArrayLIst, предназначенный для хранения объектов
типа Б

sort(); может принимать только списки объектов Comparable

В контексте обобщений ключевое слово extends подразумевает отношение Is-a и работает как для классов, так и для
интерфейсов

Если вы передадите Comparator методу sort();, то именно он будет определять порядок сортировки, а не методы compareTo(); принадлежавшие отдельным элементам

Вызов sort(List o); с одним аргументом означает, что порядок определяю методы compareTo(); каждого элема. По этой причине элемы списка должны реализовать интерфейс Comparable

Вызов sort(List o, Comparator c); означает, что методы compareTo(); принадлежащие элемам из списка, не будут вызываться. Вместо этого будет задействован метод compare(); из Comparator. В таком случае элемы списка не должны реализовывать интейрфейс Comparable

Интерфейс Comparable используется для сравнения объектов, используя естественный порядок (по возрастанию), что бы его имплементировать нужно перезаписать метод compareTo

Интерфейс Comparator используется для сравнения объектов, используя не естественный порядок (который мы прописываем в методе compareTo

Если объекты foo и bar равны, то вызов foo.equals(bar) должен возвращать true, а результат выполнения методов hashCode(); для обоих объектов будут совпадать. Что бы множество восприняло объекты как равные, необходимо переопределить методы hashCode и equals.Таким образом два разных объекта смогут быть восприняты как дубликаты

Правила для объектов в Java, касающиеся методов hashCode and equals:\
Если два объекта равны, то они должны иметь одинаковые идентификаторы\
Если два объекта равны, то вызов equals для каждого из них должен возвращать true. Иными словами, если (a.equals(b)), то (b.equals(a))\
Если два объекта содержат одинаковые идентификаторы, то они не обязательно должны быть равны. Но если они равны, то их идентификаторы должны совпадать\
Если вы переопределили hashCode, то должны переопределить equals\
По умолчанию hashCode генерирует уникальное целое число для каждого объекта в куче, поэтому, если вы не переопределите данный метод для определенного класса, никакие для объекта этого класса никогда не смогут рассматриваться как равны\
По умолчанию equals выполняет операцию сравнения ==, то есть проверяяет, указывают ли две ссылки на один объект в куче.Таким образом, если вы не переопределите метод equals в заданном классе, никакие два объекта этого класса никогда не будут рассматриваться, как равные, потому что ссылки на два разных объекта всегда будут содержать разные наборы битов\
a.equals(b) должно значить, что a.hashCode() == b.hashCode(). Но если a.hashCode() == b.hashCode(), это не значит что a.equals(b)

Типы эмелентов массива повторно проверяются при выполнени программы, тогда ка ктип коллекции - только на этапе компиляции
