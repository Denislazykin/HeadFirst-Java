Статический метод вызывается с помощью имени класса

Обычный метод вызывается с помощью имени ссылочной переменной

Можно запретить другому коду создавать экземпляры вашего не абстрактного класса, пометив конструктор как приватный

Можно сочетать в своем классе статические и обычные методы, хотя наличие даже одного не статического метода означает, что должен существовать способ создания экземпляра этого класса. Это оператор new или десериализация(это восстановление объекта из байт в которые был сохранен объект в результате сериализации)

Если вы пытаетесь использовать переменную экземпляра внутри метода, то компилятор подумает: "я понятия не имею в каком объекте находится переменная, о которой ты говоришь!" Если у вас в куче(хипе) 10 объектов Duck, то статический метод не будет ничего знать ни об одном из них

Статические переменные общедоступны

Все экземпляры одного класса содержат общую копию статическиой переменной

Переменные экземпляра: по одной на экземпляр

Статические переменные: по одной на класс

Все статические переменные в клаcсе инициализируются до того, как станет возможным создать объект это класса

Статический инициализатор - блок кода, который запускается при загрузке класса, но перед тем, как кто либо сможет использовать этот класс. Это отличное место для инициализации статических финализированных переменных \
class Foo { \
final static int x; \
static { \
x = 42;} \
   } \

Имена констант должны быть написаны в верхнем регистре

Инициализируйте финализированную статическую переменную: \
а) В момент ее объявления: \
public class Foo { \
public static final int FOO_X = 25; \
} \
б) В статическом инициализаторе: \
public class Bar { \
public static final double BAR_SIGN; \
static { \ 
BAR_SIGN = (double) Math.random();} \
} \

Не статические финализированные переменные: \
class Foof { \
final int size = 3; <- Теперь мы не можем менять размер \
final int whuffie; \

Foof() { \
whuffie = 42; <- нельзя менять значение whuffie \
} \
void doStuff(final int x) { \
Вы не можете изменить х \
} \
void doMore() { \
final int z = 7;} <-не можем изменить z \
} \
Финализированный метод: \
class Poof { \
final void calcWhuffie() { \
Важные вещи, которые никогда не должны быть переопределены } \
} \
Финализированный класс: \
final class MyMostPerfectClass { \
Не может быть наследован \
} \

Вы не можете менять значение финализированной переменной

Вы не можете переопределять финализированный метод

Вы не можете расширять финализированный класс(т.е. создавать дочерние классы)

Статический метод должен вызываться с помощью имени класса(Math.random;), а не ссылки на объект(myFoo.go();)

Для вызова статического метода необязательно наличие экземпляров класса в хипе

Модификатор статик хорошо подходит для служебных методов, которые не зависят от значений переменных конкректного объекта

Статические методы не связаны с конкректным экземпляром - только с классом, поэтому они не имеют доступа к любым не статическим переменным своего класса. Они просто не знают, значения из каких экземпляров нужно использовать

Статический метод не имеет доступа к нестатическому методу, т.к. последний, как правило, зависит от переменных экземпляра.

Если ваш класс содержит исключительно статические методы и вы не хотите создавать его экземпляры, то можете сделать его конструктор приватным

Статическая переменная доступна для всех членов отдельно взятого класса. Существует только одна копия статической переменной - одна на весь класс, а не для каждого объекта

Статический метотод имеет доступ к статическим переменным

Что бы создать константу в Java, нужно пометить переменную сразу двумя модификаторами: static и final

Значение финализированной переменной не может меняться после инициализации

Преобразование объекта String в значение простого типа:\
String s = "2";\
int x = Integer.parseInt(s);\
double d = Double.parseDouble("420.24);\
boolean b = new Boolean("true").booleanValue();\

Преобразование простого типа в String:\
double d = 42.5;\
String doubleString = "" + d;\
или\
double d = 42.5;\
String doubleString = Double.toString(d);\

В классе Formatter есть мощные и гибкие средства форматирования. Достаточно вызвать статический метод String.format(), передав ему значения и инструкции по форматированию

Спецификатор форматирования может содержать до пять разных частей(не включая %). Параметры в скобках [] необязательны, поэтому требуется указывать только знак процента и тип. Порядок следования важен, поэтому размещайте все используемые части именно так:\
%[номер аргумента][флаги][ширина][.разрядность] тип\
String.format("%,6.1f", 42.000);

Тип обязателен, все остальное опционально:\
%d - десятичное число (byte, short, int, char) \
%f - с плавающей точкой (float, double, BigDecimal(Неизменяемые десятичные числа))\
%x - шестнадцатеричное число (byte, short, int, long, BigInteger)
%c - символ (byte, short, int, char) 

Необходимо включать тип в инструкции форматирования.Сколько бы спецификаторов ни указывалось, тип всегда должен быть последним.

Форматирование двух аргументов:\
int one = 204566654;\
double two = 100567890.248907;\
String s = String.format("Уровень %,d из %,.2f", one, two);

%tc - полное представление даты и времени\
String.format("%tc", new Date());\
%tr - просто время\
System.out.println(String.format("%tr" , new Date()));\
%tA, %tB %td - день недели, месяц, число\
Date toDay = new Date();\
System.out.println(String.format("%tA, %tB %td", toDay, toDay, toDay));

Для текущих временых отметок используйте класс Date, для всего остального применяйте Calendar

Нельзя получить экземпляр класса Calendar, т.к. он абстрактный. Но можно вызвать из него статические методы, не имея конкректного объекта

Работа с объектами Calendar:\
Поля хранят состояние\
Дата и время могут быть инкрементированны\
Дату и время можно представить в милисекундах\
Calendar c = Calendar.getInstance();\
c.set(2022, 4, 26, 15, 05);\
long day1 = c.getTimeInMillis();\
day1 += 1000 * 60 * 60;\
c.setTimeInMillis(day1);\
System.out.println("Новый час " + c.get(c.HOUR_OF_DAY));\
c.add(c.DATE, 35);\
System.out.println("Добавить 35 дней " + c.getTime());\
c.roll(c.DATE, 35);\
System.out.println("Прокрутить 35 дней " + c.getTime());\
c.set(c.DATE, 1);\
System.out.println("Установить дату в 1 " + c.getTime());\

Если вы намереваетесь использовать статические члены всего несколько раз, лучше воздержаться от статического импорта, что бы не усложнять читабельность своего кода

Обратите внимание, что при статическом импорте вы можете использовать маски - звездочки * 

Существенная проблема использования статического импорта заключается в том, что с его помощью легко создать конфликт имен. Например у вас есть два класса с методами add().Как компилятору узнать, какой из них нужно использовать?




