У Java есть две области памяти, о которых нам нужно знать: стек и хип(куча)

Переменные экземпляра объявляются внутри класса, но за пределами метода

Локальные переменные объявляются внутри метода или задаются в качестве параметров

Все локальные переменные обитают в стеке, во фрейме соответствующего метода, в котором были объявлены

Объектные ссылки работают точно так же, как переменные простых типов - если они объявляются локально, то уходят в стек

Все объекты находятся в хипе, независимо от того, объявлена ли их ссылка локально или в качестве переменной экземпляра

Переменные экземпляра находятся внутри объектов, которым они принадлежат(в хипе)

Если переменная - это ссылка на объект, то она будет храниться вместе с ним в хипе

Конструктор - это код, который выполняется вместе с оператором new

Конструктор обязан иметь тоже имя, что и его класс, и не должен содержать тип возвращаемого значения

Вы можете использовать конструктор для инициализации состояния (т.е. переменных) создаваемого объекта

Если вы не разместите в своем классе ни одного конструктора, то компилятор создаст конструктор по умолчанию

Стандартный конструктор никогда не имеет аргументов

Если вы разместите в своем классе какой либо конструктор, то компилятор не будет создавать для вас конструктор по умолчанию

Если вам нужен конструктор без аргументов и у вас уже есть один (но с аргументами), то придется создать его самостоятельно

По возможности всегда содавайте конструктор без аргументов, что бы облегчить программистам работу с объектом. Предусматривайте значения по умолчанию.

Наличие перегруженных конструкторов означает, что в вашем классе их несколько

Перегруженные конструкторы должны иметь разные списки аргументов

Вы не можете создать два конструктора с одинаковыми списками аргументов. Это касается порядка их следования и\или типов

Переменным экземпляра присваиваются значения по умолчанию, даже если вы явно их не определили

Начиная свою работу, конструктор немедленно вызывает конструктор родительского класса, и так по цепочке вверх, пока не достигнет конструктора класса Obj

Объект Лев связан отношением Is-a с классами Животные и Объект. Если мы хотим создать экземпляр Льва, придется так же создавать его части, принадлежащие классам Животные и Объект. Этот процесс называется связыванием (формированием цепочки) конструкторов

Вызов super() внутри вашего конструктора автоматически помещает конструктор родительского класса на вершину стека

Каждый конструктор может иметь либо вызов this(), либо super(), но не оба сразу

Вызов super() или this() должен быть в самом начале каждого конструктора 

Используйте this() для вызова одного перегруженного конструктора из другого(в рамках одного класса)

Долговечность объекта полностью зависит от продолжительности жизни связанных с ним ссылочных переменных. 

Локальная переменная обитает только внутри метода, в котором была объявленна.

Переменная экземпляра существует до тех пор, пока существует объект. Если объект все еще жив, то живы и его переменные

Локальные переменные существуют до тех пор, пока их фрейм находится в стеке.Другими словами, пока метод не завершит свою работу.

Локальные переменные находятся в области видимости только того метода, в котором были объявленны.Когда он вызывает другой метод, переменные продолжают существовать, но находятся за пределами видимости(пока метод не продолжит свою работу). Вы можете использовать переменную только тогда, когда она находится в текущей области видимости(т.е. если ее метод в этот момент выполняется)

Объект становится доступным для сборщика мусора, когда исчезает его последняя ссылка.Способы избавиться от ссылки на объект:
* void go() {Life z = new Life();} Если создадим новый объект в методе, то ссылка на него перестанет быть видимой, когда метод завершит свою работу
* class ReRef{ Duck d = new Duck(); public void go() {d = new Duck()}} Первый объект становится недоступным, когда d перенастраивается на новый объект
* Явно присвоить ссылке значение null

