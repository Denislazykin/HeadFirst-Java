Клиентские и серверные приложения взаимодействуют с помощью сокетов

Сокет-это соединение между двумя приложениями, которые могут работать на разных компах(а могут и на одном)

Клиент должен знать IP адрес (или доменное имя) и ТСР-порт серверного приложения

ТСР порт - это 16 битное положительное число, которое присваивается конкректному серверному приложению. Благодаря
номерам ТСР портов разные клиенты могут подключаться к одному компу, но взаимодействовать на нем с разными приложениями

Номера портов от 0 до 1021 зарезервированы для таких сервисов, как HTTP,FTP,SMTP и тд

Клиент подключюается к серверу, создавая сокет:\
Socket s = new Socket("127.0.0.1", 4200);

Подключившись клиент может работать с входящими и исходящими потоками, предоставляемые сокетом.Это так называемые
низкоуровневые потоки\
socket.getInputStream();

Что бы прочитать данные, полученные от сервера нужно создать объект BufferReader и подключить его к InputStreamReader,
который в свою очередь связан с входящим потоком из сокета

Объект InputStreamReader - это промежуточный поток, который принимает байты и конвертирует их в текстовые(символьные)
данные.Как правило, он используется в качестве связуещего звена между выкоуровневым BufferReader и низкоуровневым
входящим потоком из сокета

Что бы записать текстовые данные на сервер, нужно создать объект PrintWriter, напрямую подключенные к исходящему потоку
из сокета. Что бы отправить строку на сервер, достаточно воспользоваться print(); или println();

На сервере используется ServerSocket который ожидает поступления клиентских запросов на определенном порту

Когда ServerSocket получает запрос, он его примает, создавая соединение с клиентом через объект Socket

Слово поток определяет отдельный исполняемый поток в Java

Любой поток в Java меет собственный стек вызовов

Thread - это класс java.lang.Thread. Объект Thread представляет собой исполняемый поток

Потоку нужно задание, которое он будет выполнять. Этот экземпляр класса, который реализует интерфейс Runnable

У интерфейса Runnable есть всего один метод - run(); Именно он помещается на дно нового стека вызовов. Проще говоря, это
первый метод, который будет запущен в новом потоке

Что бы запустить поток, нужно передать Runnable в конструктов Thread

Поток считается новым, если вы создали экземпляр класса Thread, но еще не вызвали start();

Когда вы запускаете поток(вызывая из объекта Thread етод start();), создается новый стек, на дне которого находится
run(); из Runnable. В этом состоянии поток считается работоспособным, он ожидает, когда его выберут для выполнения

Потоксчитается работающим, когда планировщик потоков в JVM выбирает его для выполнения на текущий момент.На
однопроцессорном компьютере может быть лишь один такой поток

Иногда поток меняет свое состояние с работающего на заблокированне(становится временно не работоспособным). Поток может
быть заблокирован при ожидании данных из сети. Кроме того, его могут приостановить или он ждет ответа от
заблокированного объекта

Нет гарантий, что процесс планирования будет переходить определенным образом, поэтому вы не можете быть уверены в
предсказуемости чредования своих потоков, Периодически приостанавливая их вы можете повлиять на этот процесс

Thread.sleep(); вынуждает поток приостановить свое выполнение на тот промежуток, что указан в качестве аргумента

sleep(); выбрасывает проверяемое исключение (InterruptedException), поэтому его вызовы должны быть заключены в блоки
try/catch или объявленны

С помощью sleep(); вы можете увеличить шансы каждого потока на выполнение, хотя нет гарантии, что при пробуждении поток
сразу продолжит свою работу.В большинстве случаев вызов sleep(); с правильно подоюранным хронометражем полностью решают
проблему переключения потоков

Вы можете дать имя потоку с помощью setName(); У всех потоков есть имена по умолчанию, но благодаря явно заданному имени вам будет легче их отслеживать, особенно если вы выполняете отладку и использованием print();

У вас могут быть серьезные проблемы, если несколько потоков получат доступ к одному объекту в куче

Доступ к одному объекту из разных потоков может привести к повреждению данных. Например один поток может приостановить свою работу прямо во время манипуляций с критически важным состоянием объекта

Что бы сделать объекты потокобезопасными, вам следует определиться, какие выражения должны выполняться в виде единого атомарного процесса. Иными словами, необходимо решить, какие методы должны быть выполнены до конца, прежде чем другой поток сможет запускать их из того же объекта

Используйте ключевое слово synchronized при объявлении методов, если не хотите, что бы они выполнялись в нескольких потоках одновременно

У каждого объекта есть один замок(блокировка) и один ключ к нему. Большую часть времени этот замок не важен для вас. Он имеет значение, только тогда, когда у объекта есть синхронизированные методы

При попытке запустить синхронизованный метод поток должен получить ключ для объекта, которому этот метод принадлежит. Если ключ недоступен(потому что другой поток его забрал), поток останавливается и ждет, пока не сможет получить ключ

Даже если у объекта несколько синхронизированных методов, он все равно владее только одним ключом. Если поток начал выполнять какой либо синхронизированный метод объекта, то остальные методы становятся недоступными для любого другого потока. Благодаря этому ограничению вы можете защитить данные, с которыми работают синхронизированные методы

